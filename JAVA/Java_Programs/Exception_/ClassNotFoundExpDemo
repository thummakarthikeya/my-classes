Assignment 01 :
================

Handling ClassNotFoundException in Java

Objective:
Develop a Java application that demonstrates the use of Java Reflection and exception handling. 
The program should prompt the user to enter the fully qualified name of a class and attempt to dynamically load the class using Class.forName(). 
If the class does not exist, the application must handle the resulting ClassNotFoundException gracefully.

Instructions:
-------------

-> Create a class named ClassNotFoundExpDemo:

-> Implement a constructor that takes a String parameter representing the class name.
   Access Modifier : public
   parameter : String

-> Inside the constructor, declare a variable of type Class<?>.
   Use a try block to attempt to load the class using Class.forName(className).
   Catch ClassNotFoundException and print an appropriate message along with the stack trace.

-> Create a main method:
   Inside the main method, create a Scanner object to read input from the user.
   Prompt the user to enter a class name.
   Read the user's input and pass it to the ClassNotFoundExpDemo constructor.
   Close the Scanner object.


TEST CASE 1 :
-------------
Input:
Enter the class name to load: java.lang.String

Output:
Class loaded successfully: java.lang.String


TEST CASE 2 :
--------------
Input:
Enter the class name to load: com.nareshit.Faculty

Output:
Error: Class 'com.nareshit.Faculty' not found.
java.lang.ClassNotFoundException: com.nareshit.Faculty
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:375)
	at com.testing.ClassNotFoundExpDemo.<init>(ClassNotFoundExpDemo.java:10)
	at com.testing.ClassNotFoundExpDemo.main(ClassNotFoundExpDemo.java:27)







import java.util.*;

public class ClassNotFoundExpDemo {
	public ClassNotFoundExpDemo(String str) {
		
		try {
			Class<?> cls = Class.forName(str);
			System.out.println("Class loaded succesfully"+ cls);
			
		}catch(Exception e) {
			System.out.println(e);
		}
		
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a class name:");
		String name  = sc.nextLine();
		
		ClassNotFoundExpDemo snfed = new ClassNotFoundExpDemo(name);
		
	}

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





Assignment : 02
================
Handling Multiple Exceptions in Method Overriding

Objective:
Write a Java program that demonstrates method overriding where the superclass method throws a checked exception (ClassNotFoundException), 
and the subclass overrides this method to handle various cases and throw appropriate exceptions (IllegalArgumentException).

Instructions:
-------------
-> Create a superclass BLC named ParentClass:

-> Implement a method loadingClass :
   Method name : loadingClass
   Access modifier : public 
   Return type : void
   Parameter : String

   Load the class by using Class.forName(-) method.
   Throws a checked exception, ClassNotFoundException, if the class is not found.

-> Create a subclass BLC named ChildClass:

-> Override the loadingClass method:
   Method name : loadingClass
   Access modifier : public 
   Return type : void
   Parameter : String

-> In this overridden method parameter (String), pass the class name through command 
   Line Argument(FQN), throw an IllegalArgumentException, If the class name is empty or 
   null otherwise call the super class loadingClass method to load the given class from 
   command Line Argument.

-> Create a ELC class Tester and implement the main method:

   Inside the main method, create an instance of ChildClass and call the overridden loadingClass method.

   Take the input from command line. Make sure if user is passing multiple class names
   through command line argument then we can load multiple classes.

   Use a try-catch block to catch and handle the exceptions.

Test Case 1 :
--------------
java.lang.String
Class java.lang.String loaded successfully.


Test Case 2 :
--------------
java.lang.String
java.lang.Integer
Class java.lang.String loaded successfully.
Class java.lang.Integer loaded successfully.


Test Case 3 :
--------------
null
Error: Class not found - null




package Elc;

import Blc.ChildClass;
import Blc.ParentClass;
import java.util.*;

public class Tester {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		//String str = sc.next();
		
		
		
		ChildClass cc = new ChildClass();
		
		for(int i=0; i<args.length; i++) {
			try {
				cc.loadingClass(args[i]);
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				//e.printStackTrace();
				System.out.println("Error: Class not found - "+args[i]);
			}
			
		}
		
		
	}

}



package Blc;

public class ChildClass extends ParentClass{
	public void loadingClass(String str) throws ClassNotFoundException {
		
		
		if(str.isEmpty()||str.equals(null)) {
			throw new IllegalArgumentException();
			
		}else {
			super.loadingClass(str);
		}
		
			
	}

}




package Blc;

public class ParentClass {
	public void loadingClass(String str) throws ClassNotFoundException {
	
			Class<?> cls = Class.forName(str);
			System.out.println("Class loaded succesfully"+ cls);
			
		
	}
	
}


########################################################################################
